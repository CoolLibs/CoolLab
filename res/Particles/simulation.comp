uniform float _delta_time;

layout(std430, binding = 0) buffer _positions_buffer
{
    float _positions[];
};

layout(std430, binding = 1) buffer _velocities_buffer
{
    float _velocities[];
};

struct Particle {
    vec2 position;
    vec2 velocity;
    vec2 acceleration;
};

float disk_sdf(vec2 position)
{
    return abs( length(position) - 0.5 );
}

vec2 disk_gradient(vec2 p)
{
    float h = 0.000001;
    return vec2(
        disk_sdf(p-vec2(h,0)) - disk_sdf(p+vec2(h,0)),
        disk_sdf(p-vec2(0,h)) - disk_sdf(p+vec2(0,h))
    ) / (2. * h);
}

void warp_in_bound(inout Particle particle)
{
    if (particle.position.x > 1.)
    {
        particle.position.x -= 2.;
    }
    if (particle.position.x < -1.)
    {
        particle.position.x += 2.;
    }
    if (particle.position.y > 1.)
    {
        particle.position.y -= 2.;
    }
    if (particle.position.y < -1.)
    {
        particle.position.y += 2.;
    }
}

void gravity(inout Particle particle, float g)
{
    particle.acceleration.y -= g;
}

void vortex_effect(inout Particle particle)
{
    float angle = 3.1415927535/1.1;
    vec2 trans_pos = vec2(-particle.position.y, particle.position.x);
    vec2 non_normalized_dir = 2*cos(angle)*particle.position + sin(angle)*trans_pos;
    particle.acceleration += 0.05*normalize(non_normalized_dir)/length(non_normalized_dir);
    if (length(particle.position) > 1)
    {
        particle.acceleration -= normalize(particle.position);
    }
}

void attractor_disk(inout Particle particle, float force)
{
    if(disk_sdf(particle.position) < 0) {
        force *= -1.;
    }
    particle.acceleration += disk_gradient(particle.position) * force;
}
void repulsor_disk(inout Particle particle, float force)
{
    // if(disk_sdf(particle.position) < 0) {
    //     force *= -1.;
    // }
    particle.acceleration -= disk_gradient(particle.position) * force;
}

void drag(inout Particle particle, float coefficient)
{
    float velocity_amplitude = length(particle.velocity);
    vec2 velocity_direction = normalize(particle.velocity);
    if(velocity_amplitude == 0) return;
    particle.acceleration -= coefficient * velocity_direction * velocity_amplitude * velocity_amplitude * 0.5;
}

void bounce(inout Particle particle)
{
    if (particle.position.x > 1.)
    {
        particle.position.x = 1.;
        particle.velocity.x = -particle.velocity.x;
    } else
    if (particle.position.x < -1.)
    {
        particle.position.x = -1.;
        particle.velocity.x = -particle.velocity.x;
    } else
    if (particle.position.y > 1.)
    {
        particle.position.y = 1.;
        particle.velocity.y = -particle.velocity.y;
    } else
    if (particle.position.y < -1.)
    {
        particle.position.y = -1.;
        particle.velocity.y = -particle.velocity.y;
    }
}

vec2 rayMarching(Particle particle, out bool isValid)
{
    float SURF_DIST                            = 0.001;
    float t                                    = 0.;
    int   i                                    = 0;

    for (; i < 15000; i++) {
        vec2 velocity = particle.velocity * _delta_time;
        vec2 point = particle.position + normalize(velocity) * t;
        float d   = abs(disk_sdf(point));

        t += d;
        
        if (d < SURF_DIST * 0.99){
            if(t > 0 && t < length(velocity)) {
                isValid = true;
                return point;
            }
        }
    }
    isValid = false;
    return vec2(0.);
}

void bounce_disk(inout Particle particle)
{
    bool isValid;
    vec2 intersection = rayMarching(particle, isValid);
    
    if (isValid)
    {
        // intersection find ! now we need to compute the normal, and reflect the velocity
        vec2 gradient = disk_gradient(intersection);
        
        float distance = abs(disk_sdf(particle.position));
        
        particle.position = particle.position - normalize(gradient) * distance;
        particle.velocity = reflect(particle.velocity, normalize(gradient));
    }
}

void cool_main()
{
    uint     gid = gl_GlobalInvocationID.x;
    Particle particle;
    particle.position     = vec2(_positions[gid * 2], _positions[gid * 2 + 1]);
    particle.velocity     = vec2(_velocities[gid * 2], _velocities[gid * 2 + 1]);
    particle.acceleration = vec2(0.);

    // move_right(particle);
    // vortex_effect(particle);
    // gravity(particle, 1.);
    // attractor_disk(particle, 1.);
    // repulsor_disk(particle, 1.); 
    // bounce_disk(particle);
    // drag(particle, 1.);
    bounce_disk(particle);

    particle.velocity += particle.acceleration * _delta_time;
    particle.position += particle.velocity * _delta_time; // TODO(Particles) proper integration method

    bounce(particle);

    _positions[gid * 2]      = particle.position.x;
    _positions[gid * 2 + 1]  = particle.position.y;
    _velocities[gid * 2]     = particle.velocity.x;
    _velocities[gid * 2 + 1] = particle.velocity.y;
}
