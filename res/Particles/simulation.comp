uniform float _delta_time;

layout(std430, binding = 0) buffer _positions_buffer
{
    float _positions[];
};

layout(std430, binding = 1) buffer _velocities_buffer
{
    float _velocities[];
};

struct Particle
{
    vec2 position;
    vec2 velocity;
    vec2 acceleration;
};






            
/*Float*/ float _disksdfa3e6ae5b36b44d8ab8fb4c634459a352(CoollabContext coollab_context, /*Vec2*/ vec2 position)
{
    
    return length(position) - 0.5;

}


            
/*Vec2*/ vec2 _diskgradienta3e6ae5b36b44d8ab8fb4c634459a352(CoollabContext coollab_context, /*Vec2*/ vec2 p)
{
    
    float h = 0.001;
    return vec2(
        _disksdfa3e6ae5b36b44d8ab8fb4c634459a352(coollab_context, p-vec2(h,0)) - _disksdfa3e6ae5b36b44d8ab8fb4c634459a352(coollab_context, p+vec2(h,0)),
        _disksdfa3e6ae5b36b44d8ab8fb4c634459a352(coollab_context, p-vec2(0,h)) - _disksdfa3e6ae5b36b44d8ab8fb4c634459a352(coollab_context, p+vec2(0,h))
    ) / (2. * h);

}


            
/*Particle*/ Particle _attractordiska3e6ae5b36b44d8ab8fb4c634459a352(CoollabContext coollab_context, /*Particle*/ Particle particle, /*Float*/ float force, /*Bool*/ bool repulse)
{
    
    if(repulse && _disksdfa3e6ae5b36b44d8ab8fb4c634459a352(coollab_context, particle.position) < 0) {
        force *= -1.;
    }
    particle.acceleration += _diskgradienta3e6ae5b36b44d8ab8fb4c634459a352(coollab_context, particle.position) * force;
    return particle;

}


            
/*Particle*/ Particle _Particles_a3e6ae5b36b44d8ab8fb4c634459a352(CoollabContext coollab_context, /*Particle*/ Particle particle)
{
    
    
    return particle;

}

            
/*Particle*/ Particle _Particles_ParticletoParticleArity1_a3e6ae5b36b44d8ab8fb4c634459a352(CoollabContext coollab_context, /*Particle*/ Particle in1)
{
    

return ((_Particles_a3e6ae5b36b44d8ab8fb4c634459a352(coollab_context, ((in1)))));

}


void cool_main()
{
    uint     gid = gl_GlobalInvocationID.x;
    Particle particle;
    particle.position     = vec2(_positions[gid * 2], _positions[gid * 2 + 1]);
    particle.velocity     = vec2(_velocities[gid * 2], _velocities[gid * 2 + 1]);
    particle.acceleration = vec2(0.);

    particle = _Particles_ParticletoParticleArity1_a3e6ae5b36b44d8ab8fb4c634459a352(particle);

    particle.velocity += particle.acceleration * _delta_time;
    particle.position += particle.velocity * _delta_time; // TODO(Particles) proper integration method

    _positions[gid * 2]      = particle.position.x;
    _positions[gid * 2 + 1]  = particle.position.y;
    _velocities[gid * 2]     = particle.velocity.x;
    _velocities[gid * 2 + 1] = particle.velocity.y;
}