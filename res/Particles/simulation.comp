uniform float _delta_time;

layout(std430, binding = 0) buffer _positions_buffer
{
    float _positions[];
};

layout(std430, binding = 1) buffer _velocities_buffer
{
    float _velocities[];
};

struct Particle {
    vec2 position;
    vec2 velocity;
    vec2 acceleration;
};

float disk_sdf(vec2 position)
{
    return length(position) - 0.5;
}

vec2 disk_gradient(vec2 p)
{
    float h =0.001;
    return vec2(
        disk_sdf(p-vec2(h,0)) + disk_sdf(p+vec2(h,0)),
        disk_sdf(p-vec2(0,h)) + disk_sdf(p+vec2(0,h))
    ) / (2. * h);

}

void warp_in_bound(inout Particle particle)
{
    if (particle.position.x > 1.)
    {
        particle.position.x -= 2.;
    }
    if (particle.position.x < -1.)
    {
        particle.position.x += 2.;
    }
    if (particle.position.y > 1.)
    {
        particle.position.y -= 2.;
    }
    if (particle.position.y < -1.)
    {
        particle.position.y += 2.;
    }
}

void gravity(inout Particle particle)
{
    particle.acceleration.y -= 1;
}

void vertex_effect(inout Particle particle)
{
    particle.velocity = 0.5*normalize(vec2(particle.position.y, -particle.position.x));
}

void cool_main()
{
    uint     gid = gl_GlobalInvocationID.x;
    Particle particle;
    particle.position     = vec2(_positions[gid * 2], _positions[gid * 2 + 1]);
    particle.velocity     = vec2(_velocities[gid * 2], _velocities[gid * 2 + 1]);
    particle.acceleration = vec2(0.);

    move_right(particle);
    //vertex_effect(particle);

    particle.velocity += particle.acceleration * _delta_time;
    particle.position += particle.velocity * _delta_time; // TODO(Particles) proper integration method

    _positions[gid * 2]      = particle.position.x;
    _positions[gid * 2 + 1]  = particle.position.y;
    _velocities[gid * 2]     = particle.velocity.x;
    _velocities[gid * 2 + 1] = particle.velocity.y;
}
