uniform float _delta_time;

layout(std430, binding = 0) buffer _positions_buffer
{
    float _positions[];
};

layout(std430, binding = 1) buffer _velocities_buffer
{
    float _velocities[];
};

struct Particle {
    vec2 position;
    vec2 velocity;
    vec2 acceleration;
};

float disk_sdf(vec2 position)
{
    return length(position) - 0.5;
}

vec2 disk_gradient(vec2 p)
{
    float h = 0.001;
    return vec2(
        disk_sdf(p-vec2(h,0)) - disk_sdf(p+vec2(h,0)),
        disk_sdf(p-vec2(0,h)) - disk_sdf(p+vec2(0,h))
    ) / (2. * h);
}

void move_right(inout Particle particle)
{
    particle.velocity.x += 0.1;
}

void warp_in_bound(inout Particle particle)
{
    if (particle.position.x > 1.)
    {
        particle.position.x -= 2.;
    }
    if (particle.position.x < -1.)
    {
        particle.position.x += 2.;
    }
    if (particle.position.y > 1.)
    {
        particle.position.y -= 2.;
    }
    if (particle.position.y < -1.)
    {
        particle.position.y += 2.;
    }
}

void gravity(inout Particle particle, float g)
{
    particle.acceleration.y -= g;
}

void vertex_effect(inout Particle particle)
{
    particle.velocity = 0.5*normalize(vec2(particle.position.y, -particle.position.x));
}

void attractor_disk(inout Particle particle, float force, bool repulse)
{
    if(repulse && disk_sdf(particle.position) < 0) {
        force *= -1.;
    }
    particle.acceleration += disk_gradient(particle.position) * force;
}
void repulsor_disk(inout Particle particle, float force)
{
    // if(disk_sdf(particle.position) < 0) {
    //     force *= -1.;
    // }
    particle.acceleration -= disk_gradient(particle.position) * force;
}

void drag(inout Particle particle, float coefficient)
{
    float velocity_amplitude = length(particle.velocity);
    vec2 velocity_direction = normalize(particle.velocity);
    if(velocity_amplitude == 0) return;
    particle.acceleration -= coefficient * velocity_direction * velocity_amplitude * velocity_amplitude * 0.5;
}

void cool_main()
{
    uint     gid = gl_GlobalInvocationID.x;
    Particle particle;
    particle.position     = vec2(_positions[gid * 2], _positions[gid * 2 + 1]);
    particle.velocity     = vec2(_velocities[gid * 2], _velocities[gid * 2 + 1]);
    particle.acceleration = vec2(0.);

    // move_right(particle);
    //vertex_effect(particle);
    // move_right(particle);
    gravity(particle, 1.);
    attractor_disk(particle, 20., true);
    // repulsor_disk(particle, 1.);
    drag(particle, 1.);

    particle.velocity += particle.acceleration * _delta_time;
    particle.position += particle.velocity * _delta_time; // TODO(Particles) proper integration method

    _positions[gid * 2]      = particle.position.x;
    _positions[gid * 2 + 1]  = particle.position.y;
    _velocities[gid * 2]     = particle.velocity.x;
    _velocities[gid * 2 + 1] = particle.velocity.y;
}
