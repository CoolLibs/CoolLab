INPUT UV->sRGB_StraightA 'Image 1';
INPUT UV->sRGB_StraightA 'Image 2';
INPUT UV->sRGB_StraightA 'Image 3';

INPUT float 'Border';
INPUT int 'Nb borders';
INPUT float 'Borders distance';
#include "_COOL_RES_/shaders/hexagonal_grid.glsl"

INPUT float 'Grid Size';
INPUT float 'Randomness';
INPUT float 'Seed';
INPUT int 'Image Seed';

struct Res {
    float normalized_dist_to_edge;
    ivec2 cell_idx;
    ivec2 closest_cell_idx;
};

Res voronoi(vec2 uv, float seed)
{
    ivec2 id = Cool_hex_id(uv, 'Grid Size');

    float min_dist         = 1000.;
    float min_dist_2       = 1000.;
    ivec2 cell_idx         = ivec2(-1);
    ivec2 closest_cell_idx = ivec2(-1);

    // 3 vectors to map a hexagon
    // Check Voronoi.png to see how is split the hexagone to generate random point in it
    vec2 a = vec2(-0.5, 0.5 / sqrt_3) / 'Grid Size';
    vec2 b = vec2(+0.5, 0.5 / sqrt_3) / 'Grid Size';
    vec2 c = vec2(+0.0, -1. / sqrt_3) / 'Grid Size';

    const ivec2 neighbour_offsets[7] = ivec2[7](ivec2(0, 0), ivec2(-1, -1), ivec2(0, -1), ivec2(-1, 0), ivec2(1, 1), ivec2(0, 1), ivec2(1, 0));

    for (int i = 0; i < 7; i++)
    {
        ivec2 offset_id          = neighbour_offsets[i];
        vec2  offset_cell_center = Cool_hex_center_from_hex_id(id + offset_id, 'Grid Size');

        vec2 n         = hash_0_to_1_2D_to_2D(ivec2(id) + ivec2(offset_id));
        n              = mix(vec2(0.4), vec2(1), n);
        n              = 'Randomness' * sin(n * (seed + 4.) + 100) / 2;
        int rand_0_1_2 = int(floor(hash_0_to_1_2D_to_1D(ivec2(id) + ivec2(offset_id)) * 3.));

        vec2 offset_position = offset_cell_center
                               + ((rand_0_1_2 == 0)
                                      ? n.x * a + n.y * b
                                  : (rand_0_1_2 == 1)
                                      ? n.x * b + n.y * c
                                      : n.x * c + n.y * a);

        float d = length(uv - offset_position);
        if (d < min_dist)
        {
            min_dist_2       = min_dist;
            min_dist         = d;
            closest_cell_idx = cell_idx;
            cell_idx         = id + offset_id;
        }
        else if (d < min_dist_2)
        {
            min_dist_2       = d;
            closest_cell_idx = id + offset_id;
        }
    }

    Res res;
    res.normalized_dist_to_edge = min_dist / min_dist_2;
    res.cell_idx                = cell_idx;
    res.closest_cell_idx        = closest_cell_idx;
    return res;
}

sRGB_StraightA main(UV uv)
{
    Res   voro = voronoi(uv, 'Seed');
    float id   = fract(hash_0_to_1_3D_to_1D(vec3(voro.cell_idx, 'Image Seed')));
    float id2  = fract(hash_0_to_1_3D_to_1D(vec3(voro.closest_cell_idx, 'Image Seed')));
    int   iid  = int(floor(id * 3));
    int   iid2 = int(floor(id2 * 3));
    // return vec4(vec3(id), 1.);
    vec4 color;
    if (iid == 0)
        color = 'Image 1'(uv);
    if (iid == 1)
        color = 'Image 2'(uv);
    if (iid == 2)
        color = 'Image 3'(uv);

    if (iid != iid2)
    {
        color.xyz *= smoothstep('Border' - 0.001, 'Border' + 0.001, 1. - voro.normalized_dist_to_edge);
        for (int i = -'Nb borders'; i <= 'Nb borders'; ++i)
            color.xyz *= smoothstep('Border' - 0.001, 'Border' + 0.001, 1. - voronoi(uv, 'Seed' + i * 'Borders distance').normalized_dist_to_edge);
    }
    return color;
}