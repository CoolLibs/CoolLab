/* -----------------------------------------------------------------------------
 * This file was automatically generated by a Python script.
 * PLEASE DON'T EDIT IT DIRECTLY, your changes would be overwritten the next time the script is run.
 * Instead, go to "Particle Nodes Generator/1 Force/Collision.clbtemp".
 * and see https://coollab-art.com/Tutorials/Writing%20Nodes/Particle%20nodes.
 * -----------------------------------------------------------------------------
 */

vec2 gradient91529481(vec2 p)
{
    float h = 0.001;
    return vec2(
        'Shape'(p - vec2(h, 0)) - 'Shape'(p + vec2(h, 0)),
        'Shape'(p - vec2(0, h)) - 'Shape'(p + vec2(0, h))
    ) / (2. * h);
}
    
// To learn how to write nodes, see https://coollab-art.com/Tutorials/Writing%20Nodes/Intro

INPUT UV->SignedDistance 'Shape';
INPUT int 'Iterations (Collision Quality)';
INPUT float 'Fix Shape Artifacts';

#include "_ROOT_FOLDER_/res/collision.glsl"

vec2 set_length(vec2 vector, float new_length)
{
    float len = length(vector);
    if (len < 0.000001)
        return vec2(new_length, 0.);
    return vector / len * new_length;
}

IntersectionResult2D intersect_with_shape(Particle2D particle, bool particle_is_outside)
{
    const float SURF_DIST = 0.001;
    float       t         = 0.;

    const vec2 ZERO     = vec2(0.); // HACK to work around a bug in particle_nodes_generator.py that prevents us to use a macro as a parameter of another macro
    vec2 velocity = particle.velocity * _delta_time;
    for (int i = 0; i < 'Iterations (Collision Quality)'; i++)
    {
        vec2 point = particle.position + set_length(velocity, 1.) * t;
        float d     = abs('Shape'(point) - (particle_is_outside ? particle.size : 0.));
        t += d * (1. - 'Fix Shape Artifacts');

        if (particle_is_outside && t > length(velocity))
            return IntersectionResult2D(false, ZERO, 0.);

        if (d < SURF_DIST && t > 0)
            return IntersectionResult2D(true, point, t);
    }
    return IntersectionResult2D(false, ZERO, 0.);
}

Particle2D main(Particle2D Particle)
{
    // TODO(Particles) Y a des fuites dans les collisions. Ideally this effect would be applied after the velocity has been updated and before the position has been updated.

    // Must be between 0 and 1 (exclusive of 1). The greater the value, the more precise the collision, but it also increases the likelihood of leaks.
    // const float offset_from_side = 0.5;

    float distance = 'Shape'(Particle.position) - Particle.size;

    if (distance < 0.)
    {
        IntersectionResult2D intersection = intersect_with_shape(Particle, false);
        Particle.position += set_length(Particle.velocity, intersection.distance_along_ray + Particle.size);
    }
    else
    {
        IntersectionResult2D intersection = intersect_with_shape(Particle, true);
        // float                original_length = length(Particle.velocity);

        // int compteur = 0;
        // while (intersection.has_intersected && compteur < 100)
        if (intersection.has_intersected)
        {
            vec2 shape_normal = normalize(gradient91529481(intersection.intersection_point));
            Particle.position = intersection.intersection_point;

            // float vel_length = length(Particle.velocity);
            // Particle.velocity *= 1 - intersection.distance_along_ray * offset_from_side / vel_length;
            Particle.velocity = reflect(Particle.velocity, shape_normal);

            // intersection = intersect_with_shape(Particle, true);
            // compteur++;
        }

        // Particle.velocity = set_length(Particle.velocity, original_length);
    }
    return Particle;
}
