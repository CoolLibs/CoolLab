// To learn how to write nodes, see https://coollab-art.com/Tutorials/Writing%20Nodes/Intro

INPUT UV->SignedDistance 'Shape';
INPUT int 'Iterations';
INPUT float 'Fix Artefacts';

#include "_ROOT_FOLDER_/res/collision.glsl"

vec2 gradient(vec2 p)
{
    float h = 0.001;
    return vec2(
               'Shape'(p - vec2(h, 0)) - 'Shape'(p + vec2(h, 0)),
               'Shape'(p - vec2(0, h)) - 'Shape'(p + vec2(0, h))
           )
           / (2. * h);
}

vec2 set_length(vec2 vector, float new_length)
{
    float len = length(vector);
    if (len < 0.000001)
        return vec2(new_length, 0.);
    return vector / len * new_length;
}

IntersectionResult2D intersect_with_shape(Particle2D particle, bool limit_intersection)
{
    const float SURF_DIST = 0.0000001;
    float       t         = 0.;

    for (int i = 0; i < 'Iterations'; i++)
    {
        vec2  velocity = particle.velocity * _delta_time;
        vec2  point    = particle.position + set_length(velocity, 1.) * t;
        float d        = abs('Shape'(point));
        t += d * (1. - 'Fix Artefacts');

        if (limit_intersection && t > length(velocity))
            return IntersectionResult2D(false, vec2(0.), 0.);

        if (d < SURF_DIST && t > 0)
            return IntersectionResult2D(true, point, t);
    }
    return IntersectionResult2D(false, vec2(0.), 0.);
}

Particle2D main(Particle2D Particle)
{
    // TODO(Particles) Y a des fuites dans les collisions. Ideally this effect would be applied after the velocity has been updated and before the position has been updated.

    // Must be between 0 and 1 (exclusive of 1). The greater the value, the more precise the collision, but it also increases the likelihood of leaks.
    // const float offset_from_side = 0.5;

    float distance = 'Shape'(Particle.position);

    if (distance < 0.)
    {
        IntersectionResult2D intersection = intersect_with_shape(Particle, false);
        Particle.position += set_length(Particle.velocity, intersection.distance_along_ray + Particle.size);
    }
    else
    {
        IntersectionResult2D intersection = intersect_with_shape(Particle, true);
        // float                original_length = length(Particle.velocity);

        // int compteur = 0;
        // while (intersection.has_intersected && compteur < 100)
        if (intersection.has_intersected)
        {
            vec2 shape_normal = normalize(gradient(intersection.intersection_point));
            Particle.position = intersection.intersection_point;

            // float vel_length = length(Particle.velocity);
            // Particle.velocity *= 1 - intersection.distance_along_ray * offset_from_side / vel_length;
            Particle.velocity = reflect(Particle.velocity, shape_normal);

            // intersection = intersect_with_shape(Particle, true);
            // compteur++;
        }

        // Particle.velocity = set_length(Particle.velocity, original_length);
    }
    return Particle;
}
