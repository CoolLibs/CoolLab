// To learn how to write nodes, see https://coollab-art.com/Tutorials/Writing%20Nodes/Intro

INPUT UV->SignedDistance 'Shape';
INPUT int 'Iterations';
INPUT float 'Fix Artefacts';

vec2 gradient(vec2 p)
{
    float h = 0.001;
    return vec2(
               'Shape'(p - vec2(h, 0)) - 'Shape'(p + vec2(h, 0)),
               'Shape'(p - vec2(0, h)) - 'Shape'(p + vec2(0, h))
           )
           / (2. * h);
}

vec4 rayMarching(Particle2D particle, bool is_distance_absolute)
{
    float SURF_DIST = 0.0000001;
    float t         = 0.;
    int   i         = 0;
    float d         = 0.;

    for (; i < 'Iterations'; i++)
    {
        vec2  velocity = particle.velocity * _delta_time;
        vec2  point    = particle.position + normalize(velocity) * t;

        if(is_distance_absolute) d = abs('Shape'(point)) - particle.size;
        else d = 'Shape'(point) - particle.size; // TODO(Particles) Handle filled shapes

        t += d * 'Fix Artefacts'; 

        if (d < SURF_DIST * 0.99999999)
        {
            if (t > 0 && t < length(velocity))
            {
                return vec4(point, 1., t);
            }
        }
    }
    return vec4(-1.);
}

vec4 rayMarching2(Particle2D particle, bool is_distance_absolute)
{
    float SURF_DIST = 0.0000001;
    float t         = 0.;
    int   i         = 0;
    float d         = 0.;

    for (; i < 'Iterations'; i++)
    {
        vec2  velocity = particle.velocity * _delta_time;
        vec2  point    = particle.position + normalize(velocity) * t;

        if(is_distance_absolute) d = abs('Shape'(point)) - particle.size;
        else d = 'Shape'(point) - particle.size; // TODO(Particles) Handle filled shapes

        t += d * 'Fix Artefacts'; 

        if (d < SURF_DIST * 0.99999999)
        {
            if (t > 0) return vec4(point, 1., t);
            }
        }
    }
    return vec4(-1.);
}

vec2 set_length(vec2 vector, float new_length)
{
    return normalize(vector) * new_length;
}

Particle2D main(Particle2D particle)
{
    // TODO(Particles) Y a des fuites dans les collisions. Ideally this effect would be applied after the velocity has been updated and before the position has been updated.
    
    // Must be between 0 and 1 (exclusive of 1). The greater the value, the more precise the collision, but it also increases the likelihood of leaks.
    const float offset_from_side = 0.5;

    float distance = 'Shape'(particle.position);
    
    if (distance > 0.) {
        vec4  intersection    = rayMarching(particle, true);
        int   compteur        = 0;
        float original_length = length(particle.velocity);

        while (intersection.z > 0 && compteur < 10000)
        {
            vec2 gradient     = gradient(intersection.xy);
            particle.position = mix(particle.position, intersection.xy, offset_from_side);

            float vel_length = length(particle.velocity);
            particle.velocity *= 1 - intersection.w * offset_from_side / vel_length;
            particle.velocity = reflect(particle.velocity, normalize(gradient));

            intersection = rayMarching(particle, true);
            compteur++;
        }

        particle.velocity = set_length(particle.velocity, original_length);

        return particle;
    }

    else {
        vec4 intersection = rayMarching2(particle, true);
        particle.position = mix(particle.position, intersection.xy, -offset_from_side);

        return particle;
    }
}
