INPUT int `SizeGrid`; //default 5 min 1 max 20
INPUT float `t`;



vec2 pixToID1(vec2 uv){
    //return floor(vec2(uv.x + 0.57735*uv.y, 1.1547*uv.y) + 1./3.);
    // vec2 scale = vec2(1.,sqrt(3));
    return floor((uv+vec2(0, 0.25)) / vec2(1.,sqrt(3)) - vec2(0, 0.25));
}
vec2 id1ToCenter(vec2 id){
    return (id + 0.5)*vec2(1.,sqrt(3));
}
vec2 id2ToCenter(vec2 id){
return (id +1.)*vec2(1.,sqrt(3));
}
vec2 pixToID2(vec2 uv){
    return floor((uv-vec2(0.5)+vec2(0, 0.25))/vec2(1.,sqrt(3))-vec2(0, 0.25));
}

vec2 IDtoCenterPix(vec2 id){
    return (vec2(id.x - id.y*.5, sqrt(3)/2* id.y) +vec2(0.5,0.5*sqrt(3)))/`SizeGrid`;
}



vec2 HexCoord(vec2 uv){
    // float sqrt_3 = 1.73205;

    // vec2 r = vec2(1.,sqrt_3);
    // vec2 h = r*0.5;

    // vec2 a = mod(uv,r)-h;
    // vec2 b = mod(uv-h,r)-h;
    
    // vec2 gv = dot(a,a) <= dot(b,b) ? a : b-0.00001;

    vec2 id1 = pixToID1(uv);
    vec2 id2 = pixToID2(uv);

    vec2 center1 = id1ToCenter(id1);
    vec2 center2 = id2ToCenter(id2);


    //ivec2 id = ivec2(floor(uv-gv).x,floor(uv-gv).y);
    vec2 id = dot(uv-center1,uv-center1) <= dot(uv-center2,uv-center2) 
    ? id1.x * vec2(1, 0) +id1.y *vec2(1,2)  
    : id2.x * vec2(1, 0) +id2.y *vec2(1,2) + vec2(1, 1) ;
    return id;
}

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}


//former version of id -> pixel center
// vec2 hex_center_global(vec2 id){
//     vec2 baseX = vec2(1.,0.)/`SizeGrid`;
//     vec2 baseY = vec2(-0.5,sqrt(3)/2.)/`SizeGrid`;

//     vec2 mainCellCenter = id.x*baseX+id.y*baseY; // is global position of the center cell
//     return mainCellCenter;
// }



float main(UV uv)
{
    vec2 id = HexCoord(uv*`SizeGrid`);


    //return vec3(id.y)/10.;
    //return vec3(gv_id.xy,0.);


    // return vec3(
    //     smoothstep(0.1, 0.11, length(uv - IDtoCenterPix(vec2(0, 15)))),
    //     gv_id.xy
    //     );

    float minDist = 1000.;

    
    // //return vec3(step(0.01, gv_id.x)*step(gv_id.x, 0.99)*step(0.01, gv_id.y)*step(gv_id.y, 0.99));


    // return vec3(
    //     smoothstep(0.3/`SizeGrid`, 0.4/`SizeGrid`, length(uv - IDtoCenterPix(vec2(0,0)))),
    //     gv_id.xy
    //     );

    vec2 a = vec2(-0.5,0.5/sqrt(3))/`SizeGrid`;
    vec2 b = vec2(0.5,0.5/sqrt(3))/`SizeGrid`;
    vec2 c = vec2(0.,-1./sqrt(3))/`SizeGrid`;

    ivec2 listAround[7] = ivec2[7](ivec2(0,0), ivec2(-1,-1),ivec2(0,-1),ivec2(-1,0),ivec2(1,1),ivec2(0,1),ivec2(1,0));


    for(int i=0;i<=6;i++){
        vec2 offsetID = listAround[i];
        vec2 offsetCellCenter = IDtoCenterPix(id+offsetID);

        //return id/3;
        vec2 n = hash_0_to_1_2D_to_2D(ivec2(id)+ivec2(offsetID));
        vec2 offPos = offsetCellCenter;
        float part = floor(rand(ivec2(id)+ivec2(offsetID))*3.);
        //return part/3;

        if (id ==0.){
            offPos += n.x*a+n.y*b;
        }

        if (id ==1.){
            offPos += n.x*b+n.y*c;
        }
        else{
            offPos += n.x*c+n.y*a;
        }

        // offPos += vec2(0.1, 0.);
        
        float d = length(uv-offPos);
        // return d;
        if (d<minDist){
            minDist = d;
        }
    }

    
    

    // for(int y = -1; y<=1; y++){
    //     for(int x = -1; x<=1; x++){
    //         if (x!=-1 && y!=0 || (x==0 && y==0)) break; // cell not include
        
    //         ivec2 offs = ivec2(x,y);
    //         vec2 offsetCellCenter = mainCellCenter + (x*baseX+y*baseY);
            
    //         float id = floor(rand(id+offs)*3.);
    //         //return id/3;
    //         vec2 n = hash_0_to_1_2D_to_2D(id+offs);
    //         vec2 offPos = offsetCellCenter;
    //         if (id ==0.){
    //             offPos = n.x*a+n.x*b;
    //         }

    //         if (id ==1.){
    //             offPos = n.x*b+n.x*c;
    //         }
    //         else{
    //             offPos = n.x*c+n.x*a;
    //         }

    //         //return offPos;
    //         //vec2 p = sin(n*(`t`+4.))/2.+offs;
    //             float d = length(gv+0.1);

    //         if (d<minDist){
    //             minDist = d;
    //         }

    //         if (d<minDist){
    //             minDist = d;
    //         }
    //     }
    // }

    // vec2 offsetCellCenter1 = mainCellCenter + -2*baseX+0*baseY;
    // vec2 offsetCellCenter2 = mainCellCenter + baseX+2*baseY;
    // float d1 = length(offsetCellCenter1+0.1);
    // float d2 = length(offsetCellCenter2+0.1);

    // if (min(d1,d2)<minDist) minDist= min(d1,d2);


    return minDist*`SizeGrid`;
}
