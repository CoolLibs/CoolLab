// To learn how to write nodes, see https://coollibs.github.io/lab/Writing%20Nodes/Intro

// Resources about hexagons:
// https://www.youtube.com/watch?v=VmrIDyYiJBA&ab_channel=TheArtofCode
// https://andrewhungblog.wordpress.com/2018/07/28/shader-art-tutorial-hexagonal-grids/

INPUT float `Grid Size`;
INPUT float `Offset`;

// pixel -> id of the first grid
vec2 pix_to_grid_ID1(vec2 uv)
{
    return floor((uv + vec2(0, 0.25)) / vec2(1., sqrt_3) - vec2(0, 0.25));
}
vec2 id1_to_center(vec2 id)
{
    return (id + 0.5) * vec2(1., sqrt_3);
}

// pixel -> id of the second grid
vec2 id2_to_center(vec2 id)
{
    return (id + 1.) * vec2(1., sqrt_3);
}
vec2 pix_to_grid_id2(vec2 uv)
{
    return floor((uv - vec2(0.5) + vec2(0, 0.25)) / vec2(1., sqrt_3) - vec2(0, 0.25));
}

vec2 hex_id(vec2 uv)
{
    vec2 id1 = pix_to_grid_ID1(uv);
    vec2 id2 = pix_to_grid_id2(uv);

    vec2 center1 = id1_to_center(id1);
    vec2 center2 = id2_to_center(id2);

    vec2 id = length_squared(uv - center1) < length_squared(uv - center2)
                  ? id1.x * vec2(1, 0) + id1.y * vec2(1, 2) + vec2(0, 1)
                  : id2.x * vec2(1, 0) + id2.y * vec2(1, 2) + vec2(1, 2);
    return id;
}

float vector_angle(vec2 vec){
    return (vec.y>0) ? acos(dot(vec,vec2(1,0))/length(vec)) : 2*PI - acos(dot(vec,vec2(1,0))/length(vec));
}

vec2 hex_uv(vec2 uv)
{
    vec2 r = vec2(1., sqrt_3);
    vec2 h = r * 0.5;

    vec2 a = mod(uv, r) - h;
    vec2 b = mod(uv - h, r) - h;

    return dot(a, a) < dot(b, b)
               ? a
               : b;
}

UV main(UV Input)
{
    Input *= `Grid Size`;

    vec2 gv = hex_uv(Input);
    vec2 id = hex_id(Input);

    float angle = vector_angle(gv);
    
    float id_triangle = (angle*360/(2*PI)>330.)? 0. : floor((angle*360/(2*PI)+30.)/60);
    float angle_middle = (id_triangle*60./360.)*2*PI;
    
    vec2 v = vec2((2./6.)*cos(angle_middle),(2./6.)*sin(angle_middle)) * `Offset`;

    vec2 middle = ((id.x+1.)*vec2(1.,0.) + id.y*vec2(-0.5,sqrt_3/2.)) /`Grid Size`;

    return middle+v;
}
