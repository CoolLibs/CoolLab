INPUT float `Hue`;
INPUT float `Saturation`;
INPUT float `Luminosity`;

float Hue_2_RGB(float v1, float v2, float vH)             //Function Hue_2_RGB
{
   if ( vH < 0 ) vH += 1;
   if( vH > 1 ) vH -= 1;
   if ( ( 6 * vH ) < 1 ) return ( v1 + ( v2 - v1 ) * 6 * vH );
   if ( ( 2 * vH ) < 1 ) return ( v2 );
   if ( ( 3 * vH ) < 2 ) return ( v1 + ( v2 - v1 ) * ( ( 2 / 3 ) - vH ) * 6 );
   return ( v1 );
}

LinearRGB main(LinearRGB c){	
	//RGB->HSL
	float r = c.x;
	float g = c.y;
	float b = c.z;
	float min = (r<=g)?((r<=b)? r : b):((g<=b)? g : b);
	float max = (r>g)?((r>b)? r : b):((g>b)? g : b);
	float delta = max-min;
	
	float saturation = 0.;
	float hue = 0.;
	float luminosity=(max+min)/2.;

	if (delta>0.001){ //delta float
		saturation = (luminosity<=0.5)? delta/(max+min) : delta/(2.0-max-min);

		float del_R = ( ( ( max - r ) / 6 ) + ( max / 2 ) ) / max;
		float del_G = ( ( ( max - g ) / 6 ) + ( max / 2 ) ) / max;
		float del_B = ( ( ( max - b ) / 6 ) + ( max / 2 ) ) / max;

		if ( r == max ) hue = del_B - del_G;
		else if ( g == max ) hue = ( 1 / 3 ) + del_R - del_B;
		else if ( b == max ) hue = ( 2 / 3 ) + del_G - del_R;

		if ( hue < 0 ) hue += 1;
		if ( hue > 1 ) hue -= 1;
	}

	// Modification

	c.x=hue;//+`Hue`;
	c.y=saturation;//*`Saturation`;
	c.z=luminosity;//*`Luminosity`;

	float hue1 = c.x;
	float saturation1 = c.y;
	float luminosity1 = c.z;

	// return c;
	//HSL -> sRGB
	//Saturation!=0 max qu'image en N&B
	if ((c.y)==0.){
		c = vec3(luminosity1);
	}
	else {
		float var_2;
		if ( luminosity < 0.5 ) var_2 = luminosity * ( 1 + saturation );
   		else           var_2 = ( luminosity + saturation ) - ( saturation * luminosity );

		float var_1 = 2 * luminosity - var_2;

		hue1 = Hue_2_RGB( var_1, var_2, hue + ( 1 / 3 ) );
		c.y = Hue_2_RGB( var_1, var_2, hue );
		luminosity1 = Hue_2_RGB( var_1, var_2, hue - ( 1 / 3 ) );
		// float temp1 = (luminosity1<0.5)? luminosity*(1.+c.y) : luminosity+c.y-(c.y*luminosity);
		// float temp2 = 2*luminosity-temp1;
		// hue1/=360;
		// float tempRed = hue1 + 0.333;
		// float tempGreen = hue1;
		// float tempBlue = hue1 - 0.333;
		// float tempArray [] = {tempRed,tempGreen,tempBlue};
		// for (int i=0; i<3;i++){
		// 	if(tempArray[i]>1){
		// 		tempArray[i]+=-1;
		// 	}
		// 	else if(tempArray[i]<0){
		// 		tempArray[i]+=1;
		// 	}
		// }
		// vec3 rgb =  vec3(0);
		// for (int i=0; i<3; i++){
		// 	if(6*tempArray[i]<1) rgb[i]=temp2 + (temp1-temp2)*6*tempArray[i];
		// 	else if(2*tempArray[0]<1) rgb[i]=temp1;
		// 	else if(3*tempArray[0]<2) rgb[i]=temp2+(temp1 - temp2) * (0.666 - tempArray[i]) * 6;
		// 	else rgb[i]=temp2;
		// }
	}

	return c;


	// //0 - Convert sRGB to RGB
	// c = vec3(
	// 	srgb2linear(c.r),
	// 	srgb2linear(c.g),
	// 	srgb2linear(c.b)
	// );

    // //1 - convert to c
	// float cMin=min(min(c.r,c.g),c.b),
	//       cMax=max(max(c.r,c.g),c.b),
	//       delta=cMax-cMin;

	// c=vec3(0.,0.,(cMax+cMin)/2.);
	// if(delta!=0.0){ //If it has chroma and isn't gray.
	// 	if(luminosity<.5){
	// 		c.y=delta/(cMax+cMin); //Saturation.
	// 	}else{
	// 		c.y=delta/(2.-cMax-cMin); //Saturation.
	// 	}
	// 	float deltaR=(((cMax-c.r)/6.)+(delta/2.))/delta,
	// 	      deltaG=(((cMax-c.g)/6.)+(delta/2.))/delta,
	// 	      deltaB=(((cMax-c.b)/6.)+(delta/2.))/delta;
	// 	//Hue.
	// 	if(c.r==cMax){
	// 		hue1*=deltaB-deltaG;
	// 	}else if(c.g==cMax){
	// 		hue1*=(1./3.)+deltaR-deltaB;
	// 	}else{ //if(c.b==cMax){
	// 		hue1*=(2./3.)+deltaG-deltaR;
	// 	}
	// 	hue1*=fract(hue1*);
	// }


    // //2 - modify
	// hue1*+=`Hue`; //->0/255
	// c.y+=`Saturation`; //->0/100
	// luminosity+=`Luminosity`; //->0/100

    // //3 - convert to RGB
	// if(c.y==0.){
	// 	return vec3(luminosity); //Luminosity.
	// }else{
	// 	float b;
	// 	if(luminosity<.5){
	// 		b=luminosity*(1.+c.y);
	// 	}else{
	// 		b=luminosity+c.y-c.y*luminosity;
	// 	}
	// 	float a=2.*luminosity-b;
	// 	return a+hue2rgb(hue1*)*(b-a);
	// 	/*vec3(
	// 		hueRamp(a,b,hue1*+(1./3.)),
	// 		hueRamp(a,b,hue1*),
	// 		hueRamp(a,b,hue1*-(1./3.))
	// 	);*/
	// }
}