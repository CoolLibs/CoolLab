#pragma once

#include "Node.h"
#include <entt/entt.hpp>

namespace NodeFactory {

	int NextId() {
		static int id = 1;
		return id++;
	}

	std::string fn_signature(std::string name) {
		return "float " + name + "(vec3 pos)";
	}

	std::string fn_declaration(std::string signature) {
		return signature + ";\n";
	}

	std::string fn_implementation(std::string signature, std::string body) {
		return signature + " {\n" + body + "\n}\n";
	}

	inline entt::entity node(entt::registry& R, std::string name) {
		entt::entity e = R.create();
		R.emplace<NodeInfo>(e,
			/*name   */ name,
			/*fn_name*/ name + "__" + std::to_string(static_cast<std::uint32_t>(e)),
			/*node_id*/ static_cast<ed::NodeId>(NextId())
		);
		return e;
	}

	inline entt::entity shape(entt::registry& R, std::string name, std::string fn_body) {
		entt::entity e = node(R, name);
		std::string fn_name = R.get<NodeInfo>(e).fn_name;
		std::string signature = fn_signature(fn_name);
		R.emplace<NodeCode>(e,
			/*fn_declaration   */ fn_declaration(signature),
			/*fn_implementation*/ fn_implementation(signature, fn_body)
		);
		R.emplace<ShapeNode>(e, OutputPinSingle(NextId()));
		R.emplace<IsTerminalNode>(e);
		return e;
	}

	inline entt::entity modifier(entt::registry& R, std::string name, CodeGenerator fn_body_generator) {
		entt::entity e = node(R, name);
		std::string fn_name = R.get<NodeInfo>(e).fn_name;
		std::string signature = fn_signature(fn_name);
		R.emplace<NodeCode>(e,
			/*fn_declaration   */ fn_declaration(signature),
			/*fn_implementation*/ "" // will be generated by NodeCodeGenerator when we call NodeEditor::gen_raymarching_shader_code 
		);
		R.emplace<ModifierNode>(e,
			///*output_node*/ entt::null,
			/*input_pin  */ InputPinSingle(NextId()),
			/*output_pin */ OutputPinSingle(NextId())
		);
		R.emplace<NodeCodeGenerator>(e, fn_body_generator);
		return e;
	}

	inline entt::entity sphere(entt::registry& R) {
		static int coutn = 0;
		return shape(R,
			"Sphere",
			"return length(pos -vec3(" + std::to_string(coutn++) + ")) - 1;"
		);
	}

	inline entt::entity cube(entt::registry& R) {
		return shape(R,
			"Cube",
			R"V0G0N( 
	vec3 q = abs(pos) - 1.; 
	return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.); 
	)V0G0N"
		);
	}

	inline entt::entity transform(entt::registry& R) {
		return modifier(R,
			"Transform",
			[&](entt::entity e) {
				//entt::entity input_node = R.get<ModifierNode>(e).input_node;
				//if (R.valid(input_node)) {
				//	std::string fn_name = R.get<NodeInfo>(input_node).fn_name;
				//	return "return " + fn_name + "(pos - vec3(1.));";
				//}
				//else {
					return std::string("return 0.;");
				//}
			}
		);
	}

} // namespace NodeFactory